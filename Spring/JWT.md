# [JWT] JWT(JSON Web Token)의 개념
> JWT는 일반적으로 클라유저를 인증하고 식별하기 위한 토큰(Token) 기반 인증이다. JWT는 일반적으로         클라이언트와 서버, 서비스와 서비스 사이 통신 시 권한 인가(Authorization)를 위해 사용하는 토큰이다. URL에 대해 안전한 문자열로 구성되어 있기 때문에 HTTP 어디든(URL, Header...) 위치할 수 있다.

>주로 회원 인증이나 정보 전달에 사용되며 세션과 달리 클라이언트에 저장되기 때문에 메모리, 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있으며 단순히 HTTP 헤더에 토큰을 첨부하는 것만으로도 단순하게 데이터를 요청하고 응답을 받을 수 있다. 
일반적으로 JWT를 통한 검증은 아래의 순서로 진행된다. 

**일반적으로 JWT를 통한 검증은 아래의 순서로 진행된다.**

1. 클라이언트가 특정 인증정보를 서버로 전송하여 서비스 인증 

2. 서버는 인증된 JWT를 생성하여 클라이언트에 제공

3. 클라이언트가 추가적인 요청할 때 JWT를 HTTP 헤더에 첨부하여 요청

4. 서버는 헤더에 첨부된 JWT를 검증하여 응답 수행

>JWT는 Base64 기반의 인코딩하여 직렬화했기 때문에 토큰 내부에 위변조 방지를 위한 개인키를 통한 전자서명이 포함되어있다. 그렇기에 JWT를 전송받은 서버는 서명을 검증하고 검증이 정상적으로 진행되면 응답을 돌려준다.


# __1. JWT의 구조__

__JWT는 크게 Header, Payload, Signature로 구성되며 세 부분을 점(.)으로 구분하는 구조이다.__

![](https://ssup2.github.io/images/theory_analysis/JWT/JWT.PNG)

## __Header__

__JWT는 인증정보를 포함하고 있는 Base64 기반의 인코딩 문자열이다. 헤더(Header)는 이 문자열을 어떻게 검증하는가에 대한 내용(JWT에서 사용할 토큰 타입, 해시 알고리즘 종류…)을 담고 있다.__

```java
{
  "typ" : "JWT",  // 토큰의 타입을 지정
  "alg" : "HS256" // 해시 알고리즘 종류
}
```

## __Payload__

__Payload에는 토큰이 전달하려는 정보가 포함돼있습니다. 정보의 한 조각을 클레임(Claim)이라고 부르고, key - value 타입으로 구성돼있습니다. 토큰에는 여러 클레임을 입력할 수 있습니다.__

__클레임은 크게 3종류가 있습니다.  [RFC 7519 클레임 종류](https://datatracker.ietf.org/doc/html/rfc7519#section-4)__

* 등록된(registered) 클레임
* 공개(public) 클레임
* 비공개(private) 클레임

### __등록된 클레임__

등록된 클레임은 클라이언트와 약속된 정보가 아닌 토큰에 정보를 담기 위해 이미 정해진 클레임입니다. 해당 클레임의 사용은 선택적이며 목록은 다음과 같습니다. 

* iss  :  토큰 발급자 
* sub  :  토큰 제목(subject)
* aud  :  토큰 대상자(audience)
* exp  :  토큰의 만료시간(expire) NumericDate 형식이여야 하고 현재 시간보다 이후로 설정되야한다. 
* nbf  :  토큰의 활성날짜 구성은 exp와 동일합니다. 
* iat  :  토큰이 발급된 시간(토큰이 발급된지 얼마나 됐는지 판단)
* jti  :  JWT의 고유 식별자로 중복처리 방지를 위해 사용되며 일회성 토큰에 유리

### __공개 클레임__
사용자 정의 클레임으로 공개 클레임들은 충돌이 방지된 key를 사용해야 합니다. 주로 URI 형식으로 작성됩니다.

```java
{
  "https://naver.com" : "true"
}
```

### __비공개 클레임__
클라이언트 ↔︎ 서버 간 협의하에 사용되는 클레임으로 공개 클레임과 같이 key의 

중복에 유의하여 사용해야 합니다.

```java
{
  "key" : "22",
  "roles" : "[{USER}, {ADMIN}]"
  "username" : "name2"
}
```

## __Signature__

JWT의 마지막 부분이 바로 서명(Signature)입니다. 이 서명은 Header, Payload를 대상으로 Base64 인코딩을 적용하고 비밀키로 해싱 처리하여 생성합니다. 

이렇게 생성된 Header, Payload, Signature는 최종적으로 아래와 같은 형태로 생성됩니다. 


![](https://t1.daumcdn.net/cfile/tistory/99ADE7385C7E19E708)


# __2. JWT 장단점__

### __장점__ ###
* URL 파라미터와 헤더로 사용 가능
* 디버깅 및 관리가 용이
* 인증에 대한 서버의 자원 부담 감소
* REST 서비스로 제공 가능
* 만료시간을 내장 가능
* 인증과 관련된 독립적인 토큰 생성 가능

### __단점__ ###
* 토큰 탈취 시 보안 문제 발생 가능성 존재
* 토큰을 모든 요청에 담아 보내야 하기 때문에 트래픽에 영향이 있다. 
* 필드가 추가될수록 토큰이 커지게 된다. 

# __3. JWT 추가정보__

## __유사한 용어정리__ ##
* __JWS (JSON Web Signature) :__ 서버에서 인증 정보를 서버의 private key로 서명한 것을 Token화한 형태
* __JWS (JSON Web Encryption) :__ 서버와 클라이언트 간 암호화된 데이터를 Token화한 형태
* __JWS (JSON Web Key) :__ JWE에서 Payload encryption에 쓰인 키를 Token화한 형태
* __JWT (JSON Web Token) :__ JWS or JWE

## __Refresh Key의 필요성__

> Access Token(JWT)를 통한 인증 방식의 문제는 만일 제 3자에게 __탈취당할 경우 보안에 취약하다는 점입니다.__

탈취당할 것을 고려하여 Token의 유효기간을 짧게 설정할 경우 그만큼 사용자는 로그인을 자주 해서 새롭게 Token을 발급받아야 하므로 불편합니다. 그러나 유효기간을 늘리자면, 토큰을 탈취당했을 때 보안에 더 취약해지게 됩니다. 

이때 사용할 수 있는 선택지가 __Refersh Token__ 입니다.

Refresh Token은 Access Token과 똑같은 형태의 JWT입니다. 처음 인증을 완료했을 때 Access Token과 동시에 발급되는 Refresh Token은 긴 유효기간을 가지면서, __Access Token이 만료됐을 때 새로 발급해주는 열쇠__ 가 됩니다(여기서 만료라는 개념은 그냥 유효기간을 지났다는 의미입니다.) 

사용 예를 간단히 들어보겠습니다. Refresh Token의 유효기간은 2주, Access Token의 유효기간은 1시간이라 하겠습니다. 클라이언트는 서버에 요청을 하다 1시간이 지나게 되면, 가지고 있는 Access Token은 만료됩니다. 그러면 Refresh Token의 유효기간 전까지는 Access Token을 새롭게 발급받을 수 있습니다.  

** Refresh Token의 유효기간이 만료됐다면, 사용자는 새로 로그인해야 합니다. Refresh Token도 탈취될 가능성이 있기 때문에 적절한 유효기간 설정이 필요해보입니다(비즈니스 특성에 따라 설정)