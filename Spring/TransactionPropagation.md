# [Spring] 트랜잭션 전파

트랜잭션은 서로 영향을 줄수 없다. 트랜잭션이 커밋, 롤백 되는것이 다른 트랜잭션에 전혀 영향이 없다. 하지만 트랜잭션이 진행되는중에 내부에서 추가로 트랜잭션이 수행되면 어떨까?

이런 경우 어떻게 동작할지에 대해 결정하는 것이 트랜잭션 전파(propagation)라 한다. 
스프링은 다양한 트랜잭션 전파 옵션을 제공한다.


## REQUIRED(기본 옵션)
A트랜잭션 안에서 B트랜잭션이 수행되면 A, B트랜잭션을 묶어서 하나의 트랜잭션으로 만들어준다. 내부 트랜잭션(B)이 외부 트랜잭션(A)에 참여하는것이다. 참여는 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다는 것이다. 이것이 전파 옵션의 기본 동작이다. 

스프링은 논리 트랜잭션과 물리 트랜잭션이라는 개념을 나눈다. 논리 트랜잭션은 하나의 물리 트랜잭션으로 묶인다. 

물리 트랜잭션이 기존에 이해하고 있는 트랜잭션이다. 커넥션을 통해 트랜잭션을 시작하고 실제 커넥션을 커밋, 롤백하는 단위이다. 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위

__REQUIRED 원칙__
* 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션도 커밋된다. 
* 한개의 논리 트랜잭션 이라도 롤백되면 물리 트랜잭션은 롤백된다. 

__내부에서 커밋, 롤백이 발생하면__

외부 트랜잭션이 시작, 커밋할때만 DB 커넥션을 통한 물리 트랜잭션을 시작하고, 커넥션을 트랜잭션 동기화 매니저에 담아둔다. 내부 트랜잭션이 실제 물리 트랜잭션을 커밋하면 트랜잭션이 종료되기 때문에 트랜잭션 동기화 매니저를 통해 해당 트랜잭션이 내부 트랜잭션 이라면 커밋, 롤백의 동작이 작동하지 않는다. 

즉 외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다. 하나의 물리 트랜잭션으로 묶이는 것이다. 하지만 내부 트랜잭션이 사용하는 커넥션은 신규(물리)가 아니므로 물리 커넥션을 제어할 수 가 없게 되는것이다.

__스프링의 외부, 내부 트랜잭션 관리__

"외부, 내부 트랜잭션을 하나의 물리 트랜잭션으로 묶어서 동작하는 방식은?"

* 외부 트랜잭션
    * 트랜잭션 매니저가 커넥션을 생성하고 물리 트랜잭션 시작한다.     
    * 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션 보관
    * 트랜잭션 매니저는 트랜잭션의 신규생성여부를 담아서 반환한다. 
    * 외부 로직이 실행되고 트랜잭션이 필요한 경우 트랜잭션 동기화 매니저에서 커넥션을 가져와 사용한다. 
* 내부 트랜잭션
    * 기존 트랜잭션이 존재하는지 확인
    * 기존 트랜잭션이 있으므로 기존 트랜잭션에 참여(새로 생성하지 않음)
    * 외부 로직 실행시 신규 트랜잭션 여부를 확인하면 기존 트랜잭션을 사용하기에 신규가 아니다. `TransactionStatus`에 트랜잭션 신규 여부 데이터가 담겨있다.

__내부 트랜잭션 롤백 시__
외부 트랜잭션이 롤백하면 당연히 물리 트랜잭션이 롤백되므로 외내부의 내용이 모두 롤백된다.
하지만 내부 트랜잭션의 롤백은 어떨까? 내부 트랜잭션은 물리 트랜잭션에 영향을 줄 수 없으니 내부에서 롤백되더라도 최종적으로 외부 트랜잭션이 커밋되면 커밋되는걸까? 

__`marked as rollback-only`__

내부 트랜잭션이 롤백되면 해당 트랜잭션에 `rollback-only`라고 마킹을 하게된다. 
이렇게 되면 외부 트랜잭션이 커밋을 실행하면 트랜잭션이 `rollbackOnly=true`로 되어 있기에 물리 트랜잭션은 롤백되게 된다. 

이럴경우 작업자는 외부 트랜잭션의 커밋을 기대했으나 결과적으로 롤백되기 때문에 기대와 다르게 실행되게 된다. 스프링은 해당 상황에 `UnexpectedRollbackException`런타임을 던져서 롤백이 발생한 상황을 전달한다. __그리고 이 트랜잭션은 재활용이 불가능하다.__

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCoMNX%2FbtrXOwzJDVl%2Fron1GEDMKMUleY7no5uKr1%2Fimg.png)


## REQUIRES_NEW
외부 트랜잭션과 내부 트랜잭션을 완전히 분리하여 사용할 수 있다.

외부 트랜잭션에서도 내부 트랜잭션을 분리하여 마치 별도의 물리 트랜잭션으로 사용 가능하다. 

실행 순서 상 내부 트랜잭션이나, 트랜잭션이 분리되었기 때문에 각각의 트랜잭션은 영향을 주고 받지 않는다. 

내부 트랜잭션을 분리하려면 내부 트랜잭션을 시작할때 `Propagation.REQUIRES_NEW`옵션을 주면 가능하다. 이는 실제로  DB커넥션이 분리되기 때문에 동시에 2개의 커넥션을 사용하는 것과 같다. 그렇기에 만약 내부 트랜잭션의 처리가 길어지면 __하나의 요청에 여러개의 커넥션을 사용하게 되는 문제가 발생할 수 있다.__

물론 트랜잭션의 진행순서는 내부 트랜잭션이 먼저 수행되고 최종적으로 내부 트랜잭션이 종료된다. 
```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
```

## ETC
트랜잭션 전파옵션(readOnly, timeout...)은 신규 트랜잭션(물리)일때만 적용된다. 
내부 트랜잭션일 경우에는 적용되지 않는다. 



