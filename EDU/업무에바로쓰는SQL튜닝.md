# 업무에 바로 쓰는 SQL 튜닝 
__MySQL, MariaDB 기반의 쿼리 튜닝 기법에 대한 효율적인 방식 제공__

## 1.2 상용 RDBMS와의 차이점
### 1.2.1 구조적 차이 

__다중화 구축 시 차이점__

* ORACLE 
    * 통합된 스토리지 하나를 공유하는 방식 
    * 공유 스토리지를 사용하므로 어느 DB서버에 접속해서 SQL 수행해도 같은 결과 출력
    * 동일한 구문(SELECT, INSERT, DELETE, UPDATE) 처리 가능
* MySQL
    * 물리적 서버마다 독립적으로 스토리지 할당 
    * 대부분 마스터(쓰기,읽기)-슬레이브(읽기) 구조로 구축
    * 따라서 동일한 구문이 처리되지 않을 수 있고 각자 서버 마다 역할이 부여된다. 

### 1.3 MySQL, MariaDB 튜닝의 방식 
대다수의 SQL 문이 중첩 루프 조인 알고리즘으로 수행, 사용 DBMS와 달리 수행 결과
가 메모리에 적재되는 캐시 기능에 한계(데이터 변경 시 캐시 내용 삭제)가 있다.

__따라서 실행계획을 분석하고 문제점을 인지하여 튜닝을 진행해야 한다.__

## 2. SQL 튜닝 용어를 직관적으로 

### 스토리지 엔진 
InnoDB, MyISAM...등 / SQL 문을 토대로 DB에 저장된 디스크나 메모리에서 필요한 데이터를 가져오는 역할 수행

스토리지 엔진이 데이터를 저장하는 방식에 따라 각각의 스토리지 엔진을 선택하여 사용할 수 있다.

*   OLTP 환경 대다수인 만큼 주로 InnoDB 엔진을 사용 
*   대량의 쓰기 트랙잭션이 발생 -> MyISAM 엔진
*   메모리 데이터 로드하여 빠르게 읽는 효과를 내려면 Memory 엔진을 사용 

__MySQL8.0, MariaDB 10.5버전부터 InnoDB 엔진 중심__

### 주요 DB 엔진 단어 
* 파서(Parser) 
    * MySQL 엔진에 포함되는 오브젝트, SQL 문을 쪼개서 최소 단위로 분리하여 트리를 만든다. 
* 전처리기(preprocessor)
    * 파서에서 생성한 트리를 토대로 SQL에 구조적 문제가 없는지 파악 
    * SQL문에 작성된 테이블, 열, 함수, 뷰와 같은 오브젝트가 유효한지 파악
* 옵티마이저
    * DBMS의 두뇌, 테이블접근, 인덱스사용등에 대한 __실행계획__ 수립
    * 최적의 실행계획을 수립하는데 오래걸리고, 최상의 실행 계획이 아닐 가능성도 있다. 
    * 작업자의 직접적인 작업 필요 가능성 존재
* 엔진 실행기 
    * MySQL엔진과 스토리지 엔진 영역 모두에 걸치는 오브젝트
    * 옵티마이저에서 수렵한 실행계획을 참고하여 스토리지 엔진에서 데이터 가져온다. 
    * 이후 데이터를 정렬, 조인, 필터링등 추가작업이 실행되기 때문에 엔진의 부하를 줄이려면 __스토리지 엔진에서 가져오는 데이터양을 줄여야한다.__

__인덱스__
* 고유 인덱스(unique index)
    * 인덱스를 구성하는 열들의 데이터가 유일할때(PK), 중복X
    * 동일한 데이터가 생성되면 고유 인덱스의 중복 체크 과정에서 에러 발생
    * PK VS 고유 인덱스 -> PK에는 NULL 허용 안된다.
* 비고유 인덱스(non-unique index)
    * 고유 인덱스에서 유일 속성만 제외한 키 
    * 인덱스의 재정렬 시 중복 체크를 거치치 않고 정렬 작업만 수행 

__뷰__
민감한 정보를 직접적으로 공개하지 않고 공개하려는 데이터만 모은 뷰를 생성하여 
제공하면 __보안 안정성__ 을 확보할 수 있다. 

### 조인 알고리즘
* 드라이빙 테이블 
    * 여러 테이블에 동시에 접근이 불가능하므로 테이블의 접근 우선순위가 존재
    * 드라이빙 테이블은 가능한 적은 결과가 반환될것으로 예상되는 테이블을 선정해야한다. 
    * 조인 조건절의 열이 인덱스로 설정되도록 구성해야한다. 
    * 인덱스로 설정이 되어 있지 않으면 풀 스캔을 해야하기 때문에 속도에 악영향
* 드리븐 테이블
    * 드라이빙 테이블을 제외한 나머지 테이블 

## 2.3 개념적 튜닝 용어
### 오브젝트 스캔 유형
    
* __테이블 스캔__
    * 테이블 풀 스캔(table full scan)
        * 인덱스를 거치치 않고 테이블로 바로 직행하여 처음부터 끝까지 데이터를 스캔한다. 
        * 성능 측면에서 부정적으로 해석        
    * __인덱스 범위 스캔(index range scan)__
        * 인덱스를 범위 기준으로 스캔한 뒤 스캔 결과를 토대로 테이블의 데이터를 찾아간다. 
        * BETWEEN ~ AND, <>, LIKE 구문 등 비교 연산 구문에 포함될 경우 인덱스 범위 스캔 수행 
        * 좁은 범위 스캔할 떄는 성능적으로 매우 효율적, 범위가 넓다면 비효율적인 방식 
    * __인덱스 풀 스캔(index full scan)__
        * 인덱스를 처음부터 끝까지 수행하는 방식
        * 테이블에 접근X, 인덱스로 구성된 열 정보만 요구하는 SQL 문에서 인덱스 풀 스캔이 수행
        * 인덱스는 테이블보다 상대적으로 적은 양을 차지하므로 테이블 풀스캔보다는 성능상 유리
        * 하지만 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 범위를 최대한 줄이는 방향으로 SQL 튜닝 해야함 
    * __인덱스 고유 스캔(index unique scan)__
        * PK, 고유 인덱스로 테이블에 접근하는 방식
        * 인덱스를 사용하는 스캔 방식 중 가장 효율적인 스캔 방법
        * where = ? 조건으로 작성하며, 해당 조인 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 떄 사용 
    * __인덱스 병합 스캔(index merge scan)__
        * 테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식
        * where 문 조건절의 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와서 모두 활용하는 방식
        * 물리적으로 분리된 개별 인덱스에 접근해야 하기에 시간이 배로 걸린다. 
            * 따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 SQL튜닝(다중 컬럼 인덱스), SQL문을 독립된 하나의 인덱스만 수행하도록 변경 가능

### 힌트
데이터베이스에 힌트를 전달하여 의도대로 작동하도록 도울 수 있다. 
* 힌트 작성 방식 
    * /*!  */ 형태의 주석처럼 힌트 명시 
    * 주석 표기 없이 쿼리의 일부로 작성하는 방법 
```SQL
SELECT 학번, 전공코드
FROM 학생 /*! USE INDEX (학생_IDX01) */
WHERE 이름 = ''
---------------------------------------------
SELECT 학번, 전공코드
FROM 학생 USE INDEX (학생_IDX01)
WHERE 이름 = ''
```

### 주요 힌트

|힌트|설명|활용도|
|---|---|---|
|STRAIGHT_JOIN|FROM 절에 작성된 테이블 순으로 조인을 유도하는 힌트|높음|
|USE INDEX|특정 인덱스를 사용하도록 유도하는 힌트|높음|
|FORCE INDEX|특정 인덱스를 사용하도록 강하게 유도하는 힌트|낮음|
|IGNORE INDEX|특정 인덱스를 사용하지 못하도록 유도하는 힌트|중간|

__주의사항__
* 옵티마이저는 무조건 힌트를 참고하진 않는다. 옵티마이저가 비효율적이라 예측하면 힌트는 무시될 수 있다. 이것은 활용도의 정도에 따라에도 달라진다. 
* 오라클의 경우 힌트에 사용된 인덱스의 상태가 변경되도 무시하고 SQL을 실행하지만 MySQL은 에러가 발생한다. 

## 3.2 실행계획 수행 

### 기본적인 실행계획 
실행계획이란 SQL 문으로 요청한 데이터를 어떻게 불러올 것인지에 대한 계획(경로)를 의미
실행 계획은 __EXPLAIN, DESCRIBE, DESC__ 3가지의 키워드로 조회 가능 
SQL문 앞에 EXPLAIN 키워드를 입력하고 실행하면 옵티마이저가 만든 실행 계획이 출력된다.
```mysql
EXPLAIN
SELECT *
FROM MEMBER
```
id, select_type등 여러 정보가 출력된다. 각 출력항목의 의미를 파악하고 튜닝의 방향을 결정해야한다. 

* id
    * 실행 순서를 표시하는 숫자, SQL이 수행되는 차례를 ID로 표기한 것으로 ID의 숫자가 작을수록 먼저 수행된것이고, ID가 같은 값이라면 두 개 테이블의 조인이 이루졌다고 해석
* select_type
    * select 문의 유형을 출력하는 항목, select 문이 from절에 위치한 것인지, 서브쿼리인지 등을 제공
    * SIMPLE
        * 내부 쿼리가 없는 select 문이라는걸 의미, 말그대로 단순한 select문
    * PRIMARY
        * 서브쿼리가 포함된 SQL문(select 문에)이 있을때 첫 번째 해당하는 구문에 표기
    * SUBQUERY
        * 독립적으로 수행되는 서브쿼리를 의미, 서브쿼리가 다수여도 단독으로 수행된다면 이에 해당한다. 
        ```sql
        EXPLAIN
        SELECT 
            (SELECT 
                COUNT(*)
             FROM 부서) AS CNT,
            (SELECT 
                MAX(연봉)
            FROM 급여) AS 급여;
        ```
    * DERIVED
        * FROM 절에 작성된 서브쿼리를 의미, FROM절의 임시 테이블인 인라인 뷰를 의미
    * MATERIALIZED
        * IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형
* table
    * 말 그대로 테이블명을 표시하는 항목
    * 서브쿼리등으로 임시 테이블을 만들어 수행될때는 <subquery#>, <derived#> 이라 출력
    * "#" 부분은 ID 값으로 사실상 저 ID값의 테이블이라 생각하면된다. 
* partitions
    * 데이터가 저장된 논리적인 영역을 표시 
    * 전체 파티션 중 특정 파티션에 선택적으로 접근하는 것이 SQL 성능 측면에 유리 
* type 
    * 테이블의 데이터를 어떻게 찾을지에 관한 정보
    * system
        * 테이블에 데이터가 없거나 한 개만 있는 경우, 성능상 최상의 type
    * const
        * 조회되는 데이터가 단 1건일 때 출력, 성능상 매우 유리한 방식
        * 고유 인덱스나 기본 키를 사용하여 단 1건의 데이터에만 접근하면 된다. 
    * eq_ref
        * 조인 수행 시 드리븐 테이블의 데이터에 접근할때 고유 인덱스, 기본 키로 단 1건의 데이터를 조회 하는 방식(성능상 가장 유리)
    * ref
        * 위와 흡사하지만, 드리븐 데이터의 접근 범위가 2개 이상일 경우를 의미
    * ref_or_null
        * IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식
        * NULL에 대해서도 인덱스 활용검색이 가능, 이때 NULL은 가장 앞쪽에 정렬
        * 테이블에서 검색할 NULL 데이터양이 적다면 효율이 있으나, 많다면 튜닝 대상
    * range
        * 테이블 내의 연속된 데이터 범위를 조회하는 유형, (=, <>, >,>=, IN, BETWEEN)등 범위 스캔을 수행하는 방식
        * 스캔할 범위가 넓으면 성능 저하의 요인이 될 수 있다. 
    * index_merge
        * 특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용
    * index
        * index 풀 스캔을 의미, 데이터 스캔하는 대상이 인덱스라는 점이 다를뿐, 끝까지 훑는 방식
        * 보통 테이블보다 크기가 작으므로 테이블 풀 스캔 방식보다는 빠를 가능성 있다. 
    * ALL
        * 테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 방식 
        * 인덱스가 없거나, 인덱스를 활용하는 게 비효율적이라 옵티마이저가 판단했을 때 선택
* possible_key
    * 옵티마이저가 SQL문을 최적화하고자 사용할 수 있는 인덱스 목록 출력
    * 다만 실제 사용한 인덱스가 아닌, 사용할 수 있는 후보군의 기본키, SQL 튜닝의 효용성은 없음
* key
    * 옵티마이저가 SQL문을 최적화하고자 사용한 기본 키(PK), 인덱스 명 
    * 어느 인텍스로 데이터를 검색했는지 확인할 수 있으므로, 비효율적인 인덱스를 사용했거나 인덱스를 사용하지 않았다면 SQL 튜닝의 대상이 된다. 
* ref 
    * 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 엑세스되었는지를 알려주는 정보
* rows
    * SQL 문을 수행하고자 접근하는 데이터의 모든 행 수를 나타내는 예측 항목
    * __최종 출력될 행 수가 아니다.__
    * SQL 문의 최종 결과 견수와 비교해 rows수가 크게 차이나면 __불필요하게 MYSQL엔진까지 데이터를 많이 가져왔다는 뜻이므로 SQL튜닝의 대상이 될 수 있다.__
* 